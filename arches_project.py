# -*- coding: utf-8 -*-
"""
/***************************************************************************
 ArchesProject
                                 A QGIS plugin
 This plugin links QGIS to an Arches project.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-09-15
        git sha              : $Format:%H$
        copyright            : (C) 2023 by Knowledge Integration
        email                : samuel.scandrett@k-int.co.uk
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from PyQt5.QtCore import Qt
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QTableView, QTableWidgetItem
from qgis.core import QgsProject, QgsVectorLayer, QgsVectorLayerCache, QgsWkbTypes
from qgis.gui import (QgsAttributeTableView, 
                      QgsAttributeTableModel, 
                      QgsAttributeTableFilterModel,
                      QgsMapLayerComboBox
                      )

# Initialize Qt resources from file resources.py
from .resources import *

# Import the code for the dialog
from .arches_project_dialog import ArchesProjectDialog

# Import the confirmation dialogs
from .dialog.create_resource_confirmation_dialog import CreateResourceConfirmation
from .dialog.edit_resource_add_confirmation_dialog import EditResourceAddConfirmation
from .dialog.edit_resource_replace_confirmation_dialog import EditResourceReplaceConfirmation

import os.path
#from shapely import GeometryCollection
import requests
from datetime import datetime


class ArchesProject:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'ArchesProject_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Arches Project')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None
        
        # Comfirmation additional dialogs 


        ## ARCHES PLUGIN SPECIFIC VARIABLES
        # Cache connection details to prevent firing duplicate connections
        self.arches_connection_cache = {}
        # Store token data to avoid regenerating every connection
        self.arches_token = {}
        self.arches_graphs_list = []
        # Store selected arches resource
        self.layers = []
        self.arches_selected_resource = {"resourceinstanceid": "",
                                         "nodeid": "",
                                         "tileid": ""
                                        }
        

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('ArchesProject', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/arches_project/icons/arches.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Arches Project'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Arches Project'),
                action)
            self.iface.removeToolBarIcon(action)


    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = ArchesProjectDialog()
            self.dlg_resource_creation = CreateResourceConfirmation()
            self.dlg_edit_resource_add = EditResourceAddConfirmation()
            self.dlg_edit_resource_replace = EditResourceReplaceConfirmation()

            ## Have everything called in here so multiple connections aren't made when plugin button pressed
            # This way only one connection is made at a time
            self.dlg.tabWidget.setCurrentIndex(0)

            # initiate the current selected layer
            self.map_selection()

            # Connection to Arches instance
            self.dlg.btnSave.clicked.connect(self.arches_connection_save)
            self.dlg.btnReset.clicked.connect(lambda: self.arches_connection_reset(hard_reset=True))

            # Get the map selection and update when changed
            self.iface.mapCanvas().selectionChanged.connect(self.map_selection)

            ## Set "Create resource" to false to begin with and only update once Arches connection made
            self.dlg.createResModelSelect.setEnabled(False)
            self.dlg.createResFeatureSelect.setEnabled(False)
            self.dlg.addNewRes.setEnabled(False)
            self.dlg.createHidePSQLLayers.setEnabled(False)
                
            # to run when layer is changed in create resource and edit resource tabs
            self.dlg.createResFeatureSelect.highlighted.connect(lambda: self.update_map_layers(combobox1=self.dlg.createResFeatureSelect,
                                                                                               combobox2=self.dlg.editResSelectFeatures,
                                                                                               checkbox=self.dlg.createHidePSQLLayers))
            self.dlg.editResSelectFeatures.highlighted.connect(lambda: self.update_map_layers(combobox1=self.dlg.editResSelectFeatures,
                                                                                              combobox2=self.dlg.createResFeatureSelect,
                                                                                              checkbox=self.dlg.editHidePSQLLayers))

            # psql layers checkbox
            self.dlg.createHidePSQLLayers.stateChanged.connect(lambda: self.show_hide_psql_layers(checkbox1=self.dlg.createHidePSQLLayers,
                                                                                                  checkbox2=self.dlg.editHidePSQLLayers,
                                                                                                  combobox1=self.dlg.createResFeatureSelect,
                                                                                                  combobox2=self.dlg.editResSelectFeatures))
            self.dlg.editHidePSQLLayers.stateChanged.connect(lambda: self.show_hide_psql_layers(checkbox1=self.dlg.editHidePSQLLayers,
                                                                                                checkbox2=self.dlg.createHidePSQLLayers,
                                                                                                combobox1=self.dlg.editResSelectFeatures,
                                                                                                combobox2=self.dlg.createResFeatureSelect))

            # to run when graph is changed in create resource
            # self.dlg.createResModelSelect.currentIndexChanged.connect(self.update_graph_options)

            # click add button - should bring up new dialog for confirmation
            self.dlg.addNewRes.clicked.connect(self.create_resource)

            ## Set "Edit Resource" to false to begin with
            self.dlg.selectedResUUID.setText("Connect to your Arches instance to edit resources.")
            self.dlg.addEditRes.setEnabled(False)
            self.dlg.replaceEditRes.setEnabled(False)
            self.dlg.editResSelectFeatures.setEnabled(False)
            #self.dlg.selectedResAttributeTable.setRowCount(0)
            self.dlg.selectedResAttributeTable.setEnabled(False)
            self.dlg.editHidePSQLLayers.setEnabled(False)

            self.dlg.addEditRes.clicked.connect(lambda: self.edit_resource(replace=False))
            self.dlg.replaceEditRes.clicked.connect(lambda: self.edit_resource(replace=True))


        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass



    def map_selection(self):
        """Get the Arches Resource from the map"""

        active_layer = self.iface.activeLayer()
        canvas = self.iface.mapCanvas()
        features = active_layer.selectedFeatures()
        print("\nmap selection has been fired because selection changed")
        print("layer:",active_layer, "features:",features)

        if len(features) > 1:
            print("Select one feature")
            self.dlg.selectedResAttributeTable.setRowCount(0)
            if self.arches_token:
                self.dlg.selectedResUUID.setText("Multiple features selected, select one feature to proceed.")
            else:
                self.dlg.selectedResUUID.setText("Connect to your Arches instance to edit resources.")
            return
        
        elif len(features) == 0:
            print("No feature selected")
            self.dlg.selectedResAttributeTable.setRowCount(0)
            if self.arches_token:
                self.dlg.selectedResUUID.setText("Select a feature to proceed.")
                self.dlg.addEditRes.setEnabled(False)
                self.dlg.replaceEditRes.setEnabled(False)
            else:
                self.dlg.selectedResUUID.setText("Connect to your Arches instance to edit resources.")
            return
        
        else:
            print("FEATURE SELECTED")
            for f in features:
                if "resourceinstanceid" in f.attributeMap():
                    
                    # Initialise attribute table in the plugin window if the geom is recognised as an Arches res
                    # if initialised when arches_token exists then would have to click off and back on to recognise
                    no_rows = len(f.attributes())
                    no_cols = 2
                    self.dlg.selectedResAttributeTable.setRowCount(no_rows)
                    self.dlg.selectedResAttributeTable.setColumnCount(no_cols)

                    # Fill table with attributes
                    for i, (k, v) in enumerate(f.attributeMap().items()):
                        feat = QTableWidgetItem(str(k))
                        val = QTableWidgetItem(str(v))
                        self.dlg.selectedResAttributeTable.setItem(i, 0, feat)
                        self.dlg.selectedResAttributeTable.setItem(i, 1, val)
                        self.dlg.selectedResAttributeTable.setRowHeight(i, 5)
                        # Store current resource info
                        if k == "resourceinstanceid":
                            self.arches_selected_resource["resourceinstanceid"] = v
                        elif k == "nodeid":
                            self.arches_selected_resource["nodeid"] = v
                        elif k == "tileid":
                            self.arches_selected_resource["tileid"] = v

                    self.dlg.selectedResAttributeTable.setHorizontalHeaderLabels([u'Feature',u'Values'])
                    self.dlg.selectedResAttributeTable.resizeColumnsToContents()

                    # if the token exists then enable the UI elements
                    if self.arches_token:
                        resource_string = "Resource: %s" % (f['resourceinstanceid'])
                        self.dlg.selectedResUUID.setText(resource_string)
                        self.dlg.addEditRes.setEnabled(True)
                        self.dlg.replaceEditRes.setEnabled(True)

                        # Save resource instance details once selected
                    else:
                        self.dlg.selectedResUUID.setText("Connect to your Arches instance to edit resources.")
                        self.dlg.addEditRes.setEnabled(False)
                        self.dlg.replaceEditRes.setEnabled(False)

                
                else: 
                    if self.arches_token:
                        self.dlg.selectedResUUID.setText("The feature selected is not an Arches resource.")
                    else:
                        self.dlg.selectedResUUID.setText("Connect to your Arches instance to edit resources.")


    def update_map_layers(self, checkbox, combobox1, combobox2):
        """Function to update new vector layers dynamically """

        if (checkbox.checkState()) == 2:
            all_current_layers = [l for l in QgsProject.instance().mapLayers().values() if l.type() == QgsVectorLayer.VectorLayer if str(l.dataProvider().name()) != "postgres"] 
        
        elif (checkbox.checkState()) == 0:
            all_current_layers = [l for l in QgsProject.instance().mapLayers().values() if l.type() == QgsVectorLayer.VectorLayer]


        if self.layers != all_current_layers:
            self.layers = all_current_layers

            combobox1.blockSignals(True)
            combobox1.clear()
            combobox1.addItems([layer.name() for layer in self.layers])
            # combobox.setCurrentIndex(0)
            combobox1.blockSignals(False)

            combobox2.blockSignals(True)
            combobox2.clear()
            combobox2.addItems([layer.name() for layer in self.layers])
            # combobox.setCurrentIndex(0)
            combobox2.blockSignals(False)


    def show_hide_psql_layers(self, checkbox1, checkbox2, combobox1, combobox2):
        """Reflect change made by checkbox to show or hide PSQL layers from self.layers"""
        # TODO: Not sure I like the way this works but it works

        def change_both_comboboxes(c):
            c.blockSignals(True)
            c.clear()
            c.addItems([layer.name() for layer in self.layers])
            c.blockSignals(False)
            # print(self.layers, "\n")


        # if checkbox1 is checked then check checkbox2
        if (checkbox1.checkState()) == 2:
            checkbox2.setChecked(True)
            self.layers = [l for l in QgsProject.instance().mapLayers().values() if l.type() == QgsVectorLayer.VectorLayer if str(l.dataProvider().name()) != "postgres"]
            change_both_comboboxes(combobox1)
            change_both_comboboxes(combobox2)

        elif (checkbox1.checkState()) == 0:
            checkbox2.setChecked(False)
            self.layers = [l for l in QgsProject.instance().mapLayers().values() if l.type() == QgsVectorLayer.VectorLayer]
            change_both_comboboxes(combobox1)
            change_both_comboboxes(combobox2)



    def geometry_conversion(self, selectedLayer):
        """Convert QGIS geometries into Arches"""

        # TODO: QGIS stores all polygons named as multipolygons even though they're separate and 
        # all multipoints as individual multipoints - these should be separated 
        geom_and_count = {} # to store geom type and how many 

        # Find what type and how many we are dealing with
        # for feature in selectedLayer.getFeatures():
        #     geomtype = str(feature.geometry().type()).split(".")
        #     if geomtype[-1] not in geom_and_count:
        #         geom_and_count[geomtype[-1]] = 1
        #     else:
        #         geom_and_count[geomtype[-1]] += 1
        #     print(feature.geometry().asPolygon())

        # if "Polygon" in geom_and_count.keys():
        #     if geom_and_count["Polygon"] == 1:
        #         all_features = [feature.geometry().asWkt() for feature in selectedLayer.getFeatures()]
        #         combined_feature = (','.join(all_features))
        #         combined_feature = combined_feature.replace("MultiPolygon","Polygon")
        #         return combined_feature

        # Return info for the confirmation dialog text box
        geometry_type_dict = {}
        for feature in selectedLayer.getFeatures():
            geom = feature.geometry()
            geomtype = str(geom.type()).split(".")
            if geomtype[-1] not in geometry_type_dict:
                geometry_type_dict[geomtype[-1]] = 1
            else:
                geometry_type_dict[geomtype[-1]] += 1

        # Would use shapely to create GEOMETRYCOLLECTION but that'd require users to install the dependency themselves
        # this is the alternative        
        all_features = [feature.geometry().asWkt() for feature in selectedLayer.getFeatures()]
        geomcoll = "GEOMETRYCOLLECTION (%s)" % (','.join(all_features))
        
        return geomcoll, geometry_type_dict



    def create_resource(self):
        """Create Resource dialog and functionality"""

        def send_new_resource_to_arches():
            try:
                results = self.save_to_arches(tileid=None,
                                            nodeid = selectedGraph["node_id"],
                                            geometry_collection=geomcoll,
                                            geometry_format=None,
                                            arches_operation="create")
                self.dlg.createResOutputBox.setText("""Successfully created a new resource with the selected geometry.
                                                    \nTo continue the creation of your new resource, navigate to...\n%s/resource/%s""" % 
                                                  (self.arches_token["formatted_url"], results["resourceinstance_id"]))
                self.dlg_resource_creation.close()
            except:
                self.dlg.createResOutputBox.setText("Resource creation FAILED.")
                self.dlg_resource_creation.close()

        def close_dialog():
            self.dlg_resource_creation.close()

        # Get info on current layer and selected graph
        selectedLayerIndex = self.dlg.createResFeatureSelect.currentIndex()
        selectedLayer = self.layers[selectedLayerIndex]
        selectedGraphIndex = self.dlg.createResModelSelect.currentIndex()
        selectedGraph = self.arches_graphs_list[selectedGraphIndex]

        geomcoll, geometry_type_dict = self.geometry_conversion(selectedLayer)
     
        # Format text box
        self.dlg_resource_creation.infoText.viewport().setAutoFillBackground(False) # Sets the text box to be invisible
        self.dlg_resource_creation.infoText.setText("")
        self.dlg_resource_creation.infoText.append("An Arches resource will be created with the following geometries:\n")
        for k,v in geometry_type_dict.items():
            self.dlg_resource_creation.infoText.append(f"{k}: {v}")

        # open dialog
        self.dlg_resource_creation.show()

        # Push button responses    
        self.dlg_resource_creation.createDialogCreate.clicked.connect(send_new_resource_to_arches)
        self.dlg_resource_creation.createDialogCancel.clicked.connect(close_dialog)




    def edit_resource(self, replace):
        """Save geometries to existing resource - either replace or add"""

        def send_edited_data_to_arches(operation_type, dialog):
            try:
                results = self.save_to_arches(tileid=self.arches_selected_resource["tileid"],
                                                nodeid = self.arches_selected_resource["nodeid"],
                                                geometry_collection=geomcoll,
                                                geometry_format=None,
                                                arches_operation=operation_type)
                print("adding data")
                dialog.close()
            except:
                print(f"Couldn't {operation_type} geometry in resource")
                dialog.close()

        def close_dialog(dialog):

            dialog.close()


        if self.arches_selected_resource:
            selectedLayerIndex = self.dlg.editResSelectFeatures.currentIndex()
            selectedLayer = self.layers[selectedLayerIndex]

            geomcoll, geometry_type_dict = self.geometry_conversion(selectedLayer)

            # Replace geometry
            if replace == True:
                # Format text box
                self.dlg_edit_resource_replace.infoText.viewport().setAutoFillBackground(False) # Sets the text box to be invisible
                self.dlg_edit_resource_replace.infoText.setText("")
                self.dlg_edit_resource_replace.infoText.append("The following geometries will be replace the existing Arches resource's geometries:\n")
                for k,v in geometry_type_dict.items():
                    self.dlg_edit_resource_replace.infoText.append(f"{k}: {v}")

                self.dlg_edit_resource_replace.editDialogCreate.disconnect()
                self.dlg_edit_resource_replace.editDialogCreate.clicked.connect(lambda: send_edited_data_to_arches(operation_type="create",
                                                                                        dialog=self.dlg_edit_resource_replace))
                self.dlg_edit_resource_replace.editDialogCancel.disconnect()
                self.dlg_edit_resource_replace.editDialogCancel.clicked.connect(lambda: close_dialog(dialog=self.dlg_edit_resource_replace))
                # Show confirmation dialog
                self.dlg_edit_resource_replace.show()

            # Add geometry to the resource
            else:
                # Format text box
                self.dlg_edit_resource_add.infoText.viewport().setAutoFillBackground(False) # Sets the text box to be invisible
                self.dlg_edit_resource_add.infoText.setText("")
                self.dlg_edit_resource_add.infoText.append("The following geometries will be added to the Arches resource:\n")
                for k,v in geometry_type_dict.items():
                    self.dlg_edit_resource_add.infoText.append(f"{k}: {v}")

                self.dlg_edit_resource_add.editDialogCreate.disconnect()
                self.dlg_edit_resource_add.editDialogCreate.clicked.connect(lambda: send_edited_data_to_arches(operation_type="append",
                                                                                    dialog=self.dlg_edit_resource_add))
                self.dlg_edit_resource_add.editDialogCancel.disconnect()
                self.dlg_edit_resource_add.editDialogCancel.clicked.connect(lambda: close_dialog(dialog=self.dlg_edit_resource_add))
                # Show confirmation dialog
                self.dlg_edit_resource_add.show()



    def save_to_arches(self, tileid, nodeid, geometry_collection, geometry_format, arches_operation):
        """Save data to arches resource"""
        if self.arches_token:
            try:
                files = {
                    'tileid': (None, tileid),
                    'nodeid': (None, nodeid),
                    'data': (None, geometry_collection),
                    'format': (None, geometry_format),
                    'operation': (None, arches_operation),
                }
                headers = {"Authorization": "Bearer %s" % (self.arches_token["access_token"])}
                response = requests.post("%s/api/node_value/" % (self.arches_token["formatted_url"]), headers=headers, data=files)
            
                if response.ok == True:
                    arches_created_resource = {"nodegroup_id": response.json()["nodegroup_id"],
                                               "resourceinstance_id": response.json()["resourceinstance_id"],
                                               "tile_id": response.json()["tileid"]}
                    return arches_created_resource
                else:
                    print("Resource creation faiiled with response code:%s" % (response.status_code))
            except:
                print("Cannot create new resource")




    def arches_connection_reset(self, hard_reset):
        """Reset Arches connection"""
        if hard_reset == True:
            # Reset connection inputs
            self.dlg.connection_status.setText("")
            self.dlg.arches_server_input.setText("")
            self.dlg.username_input.setText("")
            self.dlg.password_input.setText("")
            self.dlg.selectedResUUID.setText("Connect to your Arches instance to edit resources.")
        # Reset stored data
        self.arches_connection_cache = {}
        self.arches_token = {}
        self.arches_graphs_list = []
        # Reset Create Resource tab as no longer useable
        self.dlg.createResModelSelect.setEnabled(False)
        self.dlg.createResFeatureSelect.setEnabled(False)
        self.dlg.addNewRes.setEnabled(False)
        self.dlg.createHidePSQLLayers.setEnabled(False)
        ## Set "Edit Resource" to false to begin with
        self.dlg.addEditRes.setEnabled(False)
        self.dlg.replaceEditRes.setEnabled(False)
        self.dlg.editResSelectFeatures.setEnabled(False)
        self.dlg.selectedResAttributeTable.setRowCount(0)
        self.dlg.selectedResAttributeTable.setEnabled(False)
        self.dlg.editHidePSQLLayers.setEnabled(False)





    def arches_connection_save(self):
        """Data for connection to Arches project server"""

        # strip and remove ending slash
        def format_url():
            formatted_url = self.dlg.arches_server_input.text().strip()
            if formatted_url[-1] == "/":
                formatted_url = formatted_url[:-1]
            return formatted_url

        # once Oauth registered the clientID can be fetched and used
        def get_clientid(url):
            try:
                files = {
                    'username': (None, self.dlg.username_input.text()),
                    'password': (None, self.dlg.password_input.text()),
                }
                response = requests.post(url+"/auth/get_client_id", data=files)
                clientid = response.json()["clientid"]
                return clientid
            except:
                self.dlg.connection_status.setText("Failed to connect.\n- Check URL, username and password are correct.\n- Check the Arches instance is running.\n- Check the instance has a registered Oauth application.")
                return None
            
        def get_token(url, clientid):
            try:
                files = {
                    'username': (None, self.dlg.username_input.text()),
                    'password': (None, self.dlg.password_input.text()),
                    'client_id': (None, clientid),
                    'grant_type': (None, "password")
                }
                response = requests.post(url+"/o/token/", data=files)
                self.arches_token = response.json()
                self.arches_token["formatted_url"] = url
                self.arches_token["time"] = str(datetime.now())

                # If the token has an error status in it then break
                if "error" in self.arches_token.keys():
                    error_msg = self.arches_token["error"]
                    self.arches_token = {} # reset token to empty
                    self.dlg.connection_status.setText(f"Error connecting to token: {error_msg}.")

            except:
                self.dlg.connection_status.setText("Can't get Arches oauth2 token.")

        def get_graphs(url):
            try:
                response = requests.get("%s/graphs/" % (url))
                graphids = [x["graphid"] for x in response.json() if x["graphid"] != "ff623370-fa12-11e6-b98b-6c4008b05c4c"] # sys settings

                for graph in graphids:
                    contains_geom = False
                    req = requests.get("%s/graphs/%s" % (url, graph))
                    if req.json()["graph"]["publication_id"]:   # if graph is published
                        for nodes in req.json()["graph"]["nodes"]:
                            if nodes["datatype"] == "geojson-feature-collection":
                                contains_geom=True
                                nodegroupid = nodes["nodegroup_id"]
                                nodeid = nodes["nodeid"]
                        if contains_geom == True:
                            self.arches_graphs_list.append({
                                "graph_id":graph,
                                "name":req.json()["graph"]["name"],
                                "nodegroup_id": nodegroupid,
                                "node_id": nodeid
                            })
            except:
                pass
            

        # reset connection status on button press
        self.dlg.connection_status.setText("")

        is_valid_input = True
        if self.dlg.arches_server_input.text() == "" or str(self.dlg.arches_server_input.text()).isspace() == True:
            self.dlg.connection_status.append("Please enter the URL to your Arches project.")
            is_valid_input = False
        if self.dlg.username_input.text() == "":    
            self.dlg.connection_status.append("Please enter your username.")
            is_valid_input = False
        if self.dlg.password_input.text() == "":
            self.dlg.connection_status.append("Please enter your password.")
            is_valid_input = False


        # URL field has data in
        if is_valid_input == True:
            if self.dlg.arches_server_input.text() != "":
                formatted_url = format_url()

                self.dlg.connection_status.setText("Connecting...")

                clientid = get_clientid(formatted_url)
                if clientid:
                    # If client id NOT None then connection has been made
                    # check cache first before firing connection again

                    # re-fetch graphs before checking cache as updates may have occurred
                    self.arches_graphs_list = []
                    get_graphs(formatted_url) 

                    if self.arches_connection_cache:
                        # IF THE CACHE IS UNCHANGED THEN DON'T REFIRE CONNECTION
                        if (self.dlg.arches_server_input.text() == self.arches_connection_cache["url"] and
                            self.dlg.username_input.text() == self.arches_connection_cache["username"]):
                            self.dlg.connection_status.setText("Connection reattempt prevented as login details remain unchanged. \nGraphs have been refetched to reflect changed made on Arches.")   
                            # Re-fetch the graphs with updated list
                            if self.arches_graphs_list:
                                self.dlg.createResModelSelect.clear()
                                self.dlg.createResModelSelect.addItems([graph["name"] for graph in self.arches_graphs_list])
                            # Re-fill the comboboxes
                            self.layers = [l for l in QgsProject.instance().mapLayers().values() if l.type() == QgsVectorLayer.VectorLayer if str(l.dataProvider().name()) != "postgres"] 
                            self.dlg.createResFeatureSelect.clear()
                            self.dlg.createResFeatureSelect.addItems([layer.name() for layer in self.layers])
                            self.dlg.editResSelectFeatures.clear()
                            self.dlg.editResSelectFeatures.addItems([layer.name() for layer in self.layers])
                            return            

                    get_token(formatted_url, clientid)

                    if self.arches_token:

                        self.dlg.connection_status.setText("Connected to Arches instance.")  
                        self.dlg.selectedResUUID.setText("Connected to Arches. Select an Arches resource to proceed.")

                        # Store for preventing duplicate connection requests
                        self.arches_connection_cache = {"url": self.dlg.arches_server_input.text(),
                                                        "username": self.dlg.username_input.text()}
                        

                        # Create resource tab
                        self.dlg.createResModelSelect.clear()
                        # get all vector layers
                        self.layers = [l for l in QgsProject.instance().mapLayers().values() if l.type() == QgsVectorLayer.VectorLayer if str(l.dataProvider().name()) != "postgres"] 

                        self.dlg.createResFeatureSelect.setEnabled(True)
                        self.dlg.createResFeatureSelect.clear()
                        self.dlg.createResFeatureSelect.addItems([layer.name() for layer in self.layers])
                        
                        if self.arches_graphs_list:
                            self.dlg.createResModelSelect.setEnabled(True)
                            self.dlg.createResModelSelect.addItems([graph["name"] for graph in self.arches_graphs_list])

                            self.dlg.addNewRes.setEnabled(True)
                            self.dlg.createHidePSQLLayers.setEnabled(True)

                        # Edit resources tab
                        self.dlg.addEditRes.setEnabled(False)
                        self.dlg.replaceEditRes.setEnabled(False)
                        self.dlg.editHidePSQLLayers.setEnabled(True)
                        if self.arches_selected_resource["resourceinstanceid"]:
                            self.dlg.addEditRes.setEnabled(True)
                            self.dlg.replaceEditRes.setEnabled(True)
                        self.dlg.editResSelectFeatures.setEnabled(True)
                        self.dlg.editResSelectFeatures.clear()
                        self.dlg.editResSelectFeatures.addItems([layer.name() for layer in self.layers])
                        self.dlg.selectedResAttributeTable.setEnabled(True)


            else:
                # If clientid is None i.e no connection, reset cache and token to {}
                self.arches_connection_reset(hard_reset=False)
